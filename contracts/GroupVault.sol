// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/// @notice Holds group configuration, stake, and approvals for loans. CreditLine has special role.
contract GroupVault is AccessControl, ReentrancyGuard {
  using SafeERC20 for IERC20;

  bytes32 public constant CREDITLINE_ROLE = keccak256("CREDITLINE_ROLE");

  struct Group { address[] members; uint256 stake; uint8 minApprovals; bool active; }
  event GroupCreated(uint256 indexed gid, address[] members, uint8 minApprovals);
  event GroupStakeLocked(uint256 indexed gid, uint256 amount);
  event GroupApproval(uint256 indexed gid, uint256 indexed loanId, address approver);
  event GroupSlashed(uint256 indexed gid, uint256 amount);

  IERC20 public immutable asset; // USDC

  Group[] public groups; // gid = index
  mapping(uint256 => mapping(address => bool)) public isMember;
  mapping(uint256 => mapping(uint256 => mapping(address => bool))) public hasApproved; // gid=>loanId=>member=>bool
  mapping(uint256 => mapping(uint256 => uint256)) public approvalCount; // gid=>loanId=>count

  constructor(IERC20 _asset, address admin) {
    asset = _asset;
    _grantRole(DEFAULT_ADMIN_ROLE, admin);
  }

  function groupCount() external view returns (uint256) { return groups.length; }

  function createGroup(address[] calldata members, uint8 minApprovals) external returns (uint256 gid) {
    require(members.length >= 3 && members.length <= 12, "SIZE");
    require(minApprovals > 0 && minApprovals <= members.length, "APPROVALS");

    gid = groups.length;
    Group storage g = groups.push();
    g.minApprovals = minApprovals;
    g.active = true;
    for (uint256 i = 0; i < members.length; i++) {
      address m = members[i];
      require(m != address(0), "ZERO");
      require(!isMember[gid][m], "DUP");
      g.members.push(m);
      isMember[gid][m] = true;
    }
    emit GroupCreated(gid, g.members, minApprovals);
  }

  function lockStake(uint256 gid, uint256 amount) external nonReentrant {
    Group storage g = groups[gid];
    require(g.active, "INACTIVE");
    asset.safeTransferFrom(msg.sender, address(this), amount);
    g.stake += amount;
    emit GroupStakeLocked(gid, amount);
  }

  function approveLoan(uint256 gid, uint256 loanId) external {
    require(isMember[gid][msg.sender], "NOT_MEMBER");
    require(!hasApproved[gid][loanId][msg.sender], "ALREADY");
    hasApproved[gid][loanId][msg.sender] = true;
    uint256 n = ++approvalCount[gid][loanId];
    emit GroupApproval(gid, loanId, msg.sender);
    // no auto-callback: CreditLine or off-chain logic can check approvalCount
  }

  function slashOnDefault(uint256 gid, uint256 amount) external onlyRole(CREDITLINE_ROLE) {
    Group storage g = groups[gid];
    require(g.stake >= amount, "STAKE");
    g.stake -= amount;
    emit GroupSlashed(gid, amount);
    // funds remain in contract; could be swept by governance in future
  }

  // Explicit getter because the autogenerated getter for a struct with a dynamic array
  // does not return the array contents in a single call.
  function getGroup(uint256 gid) external view returns (
    address[] memory members,
    uint256 stake,
    uint8 minApprovals,
    bool active
  ) {
    Group storage g = groups[gid];
    return (g.members, g.stake, g.minApprovals, g.active);
  }
}
